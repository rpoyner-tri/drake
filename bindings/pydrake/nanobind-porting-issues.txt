.. -*- rst-mode -*-

=============================
   Nanobind porting issues
=============================

Compile time issues
===================

* Downstream breakage: unsolved issues in bindings cause downstream dependency
  breakage. Examples: pyi generation, tests, unused variables, etc.

* No out-of-box support for autodiff and expression as matrix/vector/array
  scalar types. Note the pybind11 was patched by Drake for this as well.
  - !! was missing a `name` field in the specialization hack at
    DRAKE_NB_NUMPY_OBJECT_DTYPE.

* dependencies on pybind11 internals that are missing/changed in nanobind:
  * detail::is_pyobject<T>
    - !! a ported version is done.
  * detail::get_type_info  --> nb_type_lookup?
    - !! the using code is ported.
  * detail::get_object_handle
    - !! the using code is ported.
  * detail::type_caster_generic
    - !! the using code is ported.

* support for custom initializers (init(lambda)) abandoned. Need polyfill or
  rewrite to placement new instead.
  - !! much of this is rewritten -- no polyfill yet.

* need to port various (deprecation, type-fiddling) wrappers to the new
  def_visitor mechanism
  * ParamInit
    - !! a new implementation on def_visitor is compilable.
  * deprecation helpers
    - !! DeprecatedParamInit is compilable.

* custom annotations need rewrite on new internals
  * pydrake::internal::ref_cycle
    - !! mostly implemented now
    - !! function names for error messages would be nice but may not work
  * pydrake::internal::builder_life_support_stash

* c++ unit tests that use python embedding need rewrite
  * create_extension_module is the clue.
  - !! rewrote all of the embed tests on master.

* issues with unique pointers as members/properties, etc.

* method for putting python objects in drake::Value<T> likely needs a rewrite
  * much dependence on internals

* cpp_function() can't be passed to def() and friends any more.
  - !! a chunk of this was to group annotations with functions in setter/getter
    situations. Can port with nanobind's for_getter() and for_setter() wrappers.

* trampolines:
  * `using Base::Base` in trampoline classes collides with stuff from
    newly-required macros.
    - !! just delete the duplicate statement.
  * trampolines: some trampoline stacks got by without making methods public;
    that doesn't work any more.
  * the new override macros don't allow change of signature. maybe there is a
    way to exploit new internals?


* GeometryId has porting issues?

* Various clone implementation hacks have smart pointer issues.

* Holder types are no longer a thing; need to work through the implications.

* nanobind's str type is less friendly; much rework will result.
  - !! (duh, dopeslap) needed to add nanobind's stl headers explicitly.

* some new restrictions on binding annotations need work.
  * can't use py::args() and leave some args unnamed?

* py::function is no longer a type.

* py::array is no longer a type. No doubt this is part of the required
  transition to nb::ndarray.

* the c++ simulator class will need adjustments to get the shared-context
  constructor stack working.

* blah Serialize() helpers now trip on enum typed fields, even though they
  are/were "registered types">
  * geometry::Role
  * systems::sensors::{ImageFileFormat,PixelScalar}

* SortedPair<GeometryId> is causing problems.

* EigenPtr is causing problems.

* kw_only() is more restrictive, or causing problems.
  - !! need to add an explicit py::arg("kwargs")

* some problem with blah::Subgraph in geom/optimization.

* dtypes apparently must be <256 bits wide. This may need a nanobind patch.

* nanobind no longer implicitly converts Python bytes to std::string.
  - !! need to add explicit overload bindings where this is desired.

* nanobind can't easily tell if a type_erased_ptr (void*, type_info) is a
  registered instance. This causes python nice type name behavior to change.

* nanobind does not implicitly convert python lists to numpy array types. See
  https://github.com/wjakob/nanobind/discussions/327.
